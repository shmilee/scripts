diff -Nur v100/src/app/api/m3u8filter-register/route.ts open-with-mpv-m3u8filter/src/app/api/m3u8filter-register/route.ts
--- v100/src/app/api/m3u8filter-register/route.ts	1970-01-01 08:00:00.000000000 +0800
+++ open-with-mpv-m3u8filter/src/app/api/m3u8filter-register/route.ts	2025-09-28 19:01:21.275381037 +0800
@@ -0,0 +1,2 @@
+export const runtime = 'nodejs';
+export { POST } from '@/lib/m3u8filter';
diff -Nur v100/src/app/api/registered-m3u8filter/route.ts open-with-mpv-m3u8filter/src/app/api/registered-m3u8filter/route.ts
--- v100/src/app/api/registered-m3u8filter/route.ts	1970-01-01 08:00:00.000000000 +0800
+++ open-with-mpv-m3u8filter/src/app/api/registered-m3u8filter/route.ts	2025-09-28 19:01:43.241380644 +0800
@@ -0,0 +1,2 @@
+export const runtime = 'nodejs';
+export { GET } from '@/lib/m3u8filter';
diff -Nur v100/src/lib/m3u8filter.ts open-with-mpv-m3u8filter/src/lib/m3u8filter.ts
--- v100/src/lib/m3u8filter.ts	1970-01-01 08:00:00.000000000 +0800
+++ open-with-mpv-m3u8filter/src/lib/m3u8filter.ts	2025-09-28 19:34:44.528764940 +0800
@@ -0,0 +1,441 @@
+/* eslint-disable no-console */
+
+import * as http from 'http';
+import * as https from 'https';
+import { NextRequest, NextResponse } from 'next/server';
+
+import { getAuthInfoFromCookie } from '@/lib/auth';
+import { getBaseUrl, resolveUrl } from "@/lib/live";
+
+export const runtime = 'nodejs';
+
+// m3u8 url_key
+const registeredKeys = new Map<string, { url: string; timestamp: number }>();
+
+export async function POST(request: NextRequest) {
+  try {
+    // 从 cookie 获取用户信息
+    const authInfo = getAuthInfoFromCookie(request);
+    if (!authInfo || !authInfo.username) {
+      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
+    }
+
+    const { url_key, original_url } = await request.json();
+    // 验证参数
+    if (!url_key || !original_url) {
+      return NextResponse.json({ success: false, error: 'Missing parameters' }, { status: 400 });
+    }
+    // 注册 key
+    registeredKeys.set(url_key, {
+      url: original_url,
+      timestamp: Date.now()
+    });
+    // 设置过期时间: 5小时
+    setTimeout(() => {
+      registeredKeys.delete(url_key);
+    }, 5 * 60 * 60 * 1000);
+    return NextResponse.json({ success: true });
+  } catch (error) {
+    return NextResponse.json({ success: false, error: 'Invalid request' }, { status: 400 });
+  }
+}
+
+// 连接池管理
+const httpsAgent = new https.Agent({
+  keepAlive: true,
+  maxSockets: 50,
+  maxFreeSockets: 10,
+  timeout: 60000,
+  keepAliveMsecs: 30000,
+});
+
+const httpAgent = new http.Agent({
+  keepAlive: true,
+  maxSockets: 50,
+  maxFreeSockets: 10,
+  timeout: 60000,
+  keepAliveMsecs: 30000,
+});
+
+// 性能统计
+const stats = {
+  requests: 0,
+  errors: 0,
+  avgResponseTime: 0,
+  totalBytes: 0,
+};
+
+
+// Ref: https://github.com/SzeMeng76/LunaTV/blob/main/src/app/api/proxy/m3u8/route.ts
+// "不"验证用户信息，方便 mpv 访问: /api/registered-m3u8filter
+export async function GET(request: NextRequest) {
+  const startTime = Date.now();
+  stats.requests++;
+
+  const { searchParams } = new URL(request.url);
+  const url_key = searchParams.get('url_key');
+  if (!url_key || !registeredKeys.has(url_key)) {
+    stats.errors++;
+    return new Response('Not Found url_key', { status: 404 });
+  }
+  const entry = registeredKeys.get(url_key);
+  if (!entry) {
+    stats.errors++;
+    return new Response('Not Found url', { status: 404 });
+  }
+  if (!entry.url) {
+    stats.errors++;
+    return new Response('Missing url', { status: 404 });
+  }
+
+  let response: Response | null = null;
+  let responseUsed = false;
+  const controller = new AbortController();
+  const timeoutId = setTimeout(() => controller.abort(), 15000); // 15秒超时
+
+  // 使用 entry.url 获取原始 m3u8 内容
+  try {
+    const decodedUrl = decodeURIComponent(entry.url);
+
+    // 选择合适的 agent
+    const isHttps = decodedUrl.startsWith('https:');
+    const agent = isHttps ? httpsAgent : httpAgent;
+
+    // 参考 hls.js fetch-loader，构建标准headers
+    const headers: Record<string, string> = {
+      'User-Agent': 'AptvPlayer/1.4.10',
+      'Accept': 'application/vnd.apple.mpegurl, application/x-mpegurl, application/octet-stream, */*',
+      'Accept-Encoding': 'identity', // 避免gzip压缩导致的处理复杂性
+      'Accept-Language': 'en-US,en;q=0.9',
+      'Cache-Control': 'no-cache',
+      'Pragma': 'no-cache',
+      'Connection': 'keep-alive'
+    };
+
+    response = await fetch(decodedUrl, {
+      cache: 'no-cache',
+      redirect: 'follow',
+      credentials: 'same-origin',
+      signal: controller.signal,
+      headers: new Headers(headers),
+      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+      // @ts-ignore - Node.js specific option
+      agent: typeof window === 'undefined' ? agent : undefined,
+    });
+
+    clearTimeout(timeoutId);
+
+    // 参考 hls.js fetch-loader 的错误处理逻辑
+    if (!response.ok) {
+      stats.errors++;
+      clearTimeout(timeoutId);
+      // 直接返回原始的 HTTP 错误，让 mpv 处理
+      // 不返回JSON，因为 mpv 期望的是M3U8内容或标准 HTTP 错误
+      return new NextResponse(
+        `HTTP Error ${response.status}: ${response.statusText}`, 
+        {
+          status: response.status,
+          statusText: response.statusText,
+          headers: {
+            'Content-Type': 'text/plain',
+            'Access-Control-Allow-Origin': '*',
+          }
+        }
+      );
+    }
+
+    const contentType = response.headers.get('Content-Type') || '';
+    const contentLength = parseInt(response.headers.get('Content-Length') || '0', 10);
+
+    // 检查内容是否为 M3U8
+    const isM3U8 = contentType.toLowerCase().includes('mpegurl') ||
+                   contentType.toLowerCase().includes('octet-stream') ||
+                   decodedUrl.includes('.m3u8');
+    if (isM3U8) {
+      // 获取最终的响应URL（处理重定向后的URL）
+      const finalUrl = response.url;
+      const m3u8Content = await response.text();
+      responseUsed = true;
+      // 更新统计信息
+      if (contentLength > 0) {
+        stats.totalBytes += contentLength;
+      } else {
+        stats.totalBytes += m3u8Content.length;
+      }
+      // 使用最终的响应URL作为baseUrl，而不是原始的请求URL
+      const baseUrl = getBaseUrl(finalUrl);
+      // 过滤重写原始 M3U8 内容
+      const modifiedContent = rewriteM3U8Content(m3u8Content, baseUrl);
+      const headers = new Headers();
+      headers.set('Content-Type', contentType || 'application/vnd.apple.mpegurl');
+      headers.set('Access-Control-Allow-Origin', '*');
+      headers.set('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, HEAD');
+      headers.set('Access-Control-Allow-Headers', 'Content-Type, Range, Origin, Accept, User-Agent');
+      headers.set('Cache-Control', 'no-cache, no-store, must-revalidate');
+      headers.set('Pragma', 'no-cache');
+      headers.set('Expires', '0');
+      headers.set('Access-Control-Expose-Headers', 'Content-Length, Content-Range, Content-Type');
+      headers.set('Content-Length', modifiedContent.length.toString());
+      return new Response(modifiedContent, { headers, status: 200 });
+    }
+
+    // 跳过非 M3U8 内容
+    throw new Error(`Non-M3U8 content type, ${contentType}`);
+
+  } catch (error) {
+    stats.errors++;
+    clearTimeout(timeoutId);
+    console.error('M3U8 filter error:', error);
+    return new Response(`M3U8 filter error: ${error}`, { status: 500 });
+
+  } finally {
+    clearTimeout(timeoutId);
+    // 确保 response 被正确关闭以释放资源
+    if (response && !responseUsed) {
+      try {
+        response.body?.cancel();
+      } catch (error) {
+        console.warn('Failed to close response body:', error);
+      }
+    }
+    // 更新性能统计
+    const responseTime = Date.now() - startTime;
+    stats.avgResponseTime = (stats.avgResponseTime * (stats.requests - 1) + responseTime) / stats.requests;
+    // 定期打印统计信息
+    //if (stats.requests % 10 === 0 && process.env.NODE_ENV === 'development') {
+    console.log(`M3U8 Filter Stats - Requests: ${stats.requests}, Errors: ${stats.errors}, Avg Response Time: ${stats.avgResponseTime.toFixed(1)}ms, Total Bytes: ${(stats.totalBytes / 1024).toFixed(1)}KB`);
+    //}
+  }
+}
+
+function filterDiscontinuityAdJump(lines: string[]): string[] {
+  const result: string[] = [];
+  let inAdSegment = false;
+
+  for (let i = 0; i < lines.length; i++) {
+    const line = lines[i].trim();
+    // 检测到 DISCONTINUITY 标签
+    if (line.startsWith('#EXT-X-DISCONTINUITY')) {
+      // 如果已经在广告段中，说明这是广告段的结束
+      if (inAdSegment) {
+        inAdSegment = false;
+        // 跳过这个结束标签，不加入结果
+        continue;
+      } else {
+        // 检查接下来的片段是否是广告
+        let isAd = false;
+        // 向后查找第一个非空且非标签的行（即URL行）
+        for (let j = i + 1; j < lines.length; j++) {
+          const nextLine = lines[j].trim();
+          if (!nextLine) continue; // 跳过空行
+          if (nextLine.startsWith('#')) {
+            // 如果遇到另一个标签，检查是否是另一个 DISCONTINUITY
+            if (nextLine.startsWith('#EXT-X-DISCONTINUITY')) {
+              // 连续的 DISCONTINUITY，可能是广告段
+              isAd = true;
+            }
+            continue;
+          }
+          // 找到第一个URL行，检查是否是广告
+          if (
+              (nextLine.startsWith('http://') || nextLine.startsWith('https://'))
+              &&
+              (nextLine.includes('/adjump') || nextLine.includes('/ad/'))
+             ) {
+            isAd = true;
+          }
+          break;
+        }
+        if (isAd) {
+          inAdSegment = true;
+          // 跳过广告段的开始标签
+          continue;
+        } else {
+          // 不是广告，保留
+          result.push(line);
+        }
+      }
+    }
+    // 如果不在广告段中，保留当前行
+    else if (!inAdSegment) {
+      result.push(line);
+    }
+    // 如果在广告段中，跳过所有行直到遇到下一个 DISCONTINUITY
+  }
+
+  return result;
+}
+
+function rewriteM3U8Content(content: string, baseUrl: string) {
+  let lines = content.split('\n');
+  const hasDiscontinuity = content.includes('#EXT-X-DISCONTINUITY');
+
+  if (hasDiscontinuity) {
+    if (process.env.MPV_FILTER_M3U8 === 'on-adjump') {
+      lines = filterDiscontinuityAdJump(lines);
+    } else {
+      // 仅过滤 #EXT-X-DISCONTINUITY 标签
+      lines = lines.filter(line => !line.startsWith('#EXT-X-DISCONTINUITY'));
+    }
+  }
+
+  const rewrittenLines: string[] = [];
+  const variables = new Map<string, string>(); // 用于 EXT-X-DEFINE 变量替换
+
+  for (let i = 0; i < lines.length; i++) {
+    let line = lines[i].trim();
+
+    // 处理空行, 丢弃
+    if (!line) {
+      continue;
+    }
+    // 处理非标签行（TS片段、嵌套M3U8等）
+    if (!line.startsWith('#')) {
+      const resolvedUrl = resolveUrl(baseUrl, line);
+      rewrittenLines.push(resolvedUrl);
+      continue;
+    }
+
+    // 使用 switch 处理各种标签
+    switch (true) {
+      // 处理变量定义 (EXT-X-DEFINE)
+      case line.startsWith('#EXT-X-DEFINE:'):
+        line = processDefineVariables(line, variables);
+        break;
+      // 处理 EXT-X-MAP 标签中的 URI
+      case line.startsWith('#EXT-X-MAP:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // 处理 EXT-X-KEY 标签中的 URI
+      case line.startsWith('#EXT-X-KEY:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // 处理 EXT-X-MEDIA 标签中的 URI (音频轨道等)，无效音轨留给 mpv
+      case line.startsWith('#EXT-X-MEDIA:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // 处理 LL-HLS 部分片段 (EXT-X-PART)
+      case line.startsWith('#EXT-X-PART:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // 处理预加载提示 (EXT-X-PRELOAD-HINT)
+      case line.startsWith('#EXT-X-PRELOAD-HINT:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // 处理会话数据 (EXT-X-SESSION-DATA) - 可能包含 URI
+      case line.startsWith('#EXT-X-SESSION-DATA:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // 处理会话密钥 (EXT-X-SESSION-KEY)
+      case line.startsWith('#EXT-X-SESSION-KEY:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // 处理内容导向 (EXT-X-CONTENT-STEERING)
+      case line.startsWith('#EXT-X-CONTENT-STEERING:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'SERVER-URI');
+        break;
+      // 处理渲染报告 (EXT-X-RENDITION-REPORT)
+      case line.startsWith('#EXT-X-RENDITION-REPORT:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // 处理日期范围标签中的 URI (EXT-X-DATERANGE)
+      case line.startsWith('#EXT-X-DATERANGE:'):
+        line = rewriteDateRangeUris(line, baseUrl, variables);
+        break;
+
+      case line.startsWith('#EXT-X-STREAM-INF:'):
+        rewrittenLines.push(line);
+        // 处理下一行的嵌套M3U8 URL
+        if (i + 1 < lines.length) {
+          i++;
+          const nextLine = lines[i].trim();
+          if (nextLine && !nextLine.startsWith('#')) {
+            let resolvedUrl = resolveUrl(baseUrl, nextLine);
+            resolvedUrl = substituteVariables(resolvedUrl, variables);
+            rewrittenLines.push(resolvedUrl);
+          } else {
+            rewrittenLines.push(nextLine);
+          }
+        }
+        continue;
+
+      // 这些标签不需要处理，直接保留
+      // 服务器控制 (EXT-X-SERVER-CONTROL)
+      //case line.startsWith('#EXT-X-SERVER-CONTROL:'):
+      // 跳过片段 (EXT-X-SKIP)
+      //case line.startsWith('#EXT-X-SKIP:'):
+      //  break;
+      // 其他未知标签直接保留
+      default:
+        break;
+    }
+
+    rewrittenLines.push(line);
+  }
+
+  return rewrittenLines.join('\n');
+}
+
+// 处理变量定义
+function processDefineVariables(line: string, variables: Map<string, string>): string {
+  const nameMatch = line.match(/NAME="([^"]+)"/);
+  const valueMatch = line.match(/VALUE="([^"]+)"/);
+  if (nameMatch && valueMatch) {
+    variables.set(nameMatch[1], valueMatch[1]);
+  }
+  return line; // 返回原始标签，让客户端处理
+}
+
+// 变量替换函数 - 参考 hls.js 标准实现
+const VARIABLE_REPLACEMENT_REGEX = /\{\$([a-zA-Z0-9-_]+)\}/g;
+
+function substituteVariables(text: string, variables: Map<string, string>): string {
+  if (variables.size === 0) {
+    return text;
+  }
+
+  return text.replace(VARIABLE_REPLACEMENT_REGEX, (variableReference: string, variableName: string) => {
+    const variableValue = variables.get(variableName);
+    if (variableValue === undefined) {
+      if (process.env.NODE_ENV === 'development') {
+        console.warn(`Missing variable definition for: "${variableName}"`);
+      }
+      return variableReference; // 保持原始引用如果变量未定义
+    }
+    return variableValue;
+  });
+}
+
+// 通用的 URI 重写函数，或其他 attrName
+function rewriteTagUri(line: string, baseUrl: string, variables: Map<string, string>, attrName: string): string {
+  const regex = new RegExp(`${attrName}="([^"]+)"`);
+  const match = line.match(regex);
+  if (match) {
+    let originalUri = match[1];
+    // 变量替换
+    if (variables) {
+      originalUri = substituteVariables(originalUri, variables);
+    }
+    const resolvedUrl = resolveUrl(baseUrl, originalUri);
+    return line.replace(match[0], `${attrName}="${resolvedUrl}"`);
+  }
+  return line;
+}
+
+// 处理日期范围中的多个URI
+function rewriteDateRangeUris(line: string, baseUrl: string, variables: Map<string, string>): string {
+  const uriMatches = Array.from(line.matchAll(/([A-Z-]+)="([^"]*(?:https?:\/\/|\/)[^"]*)"/g));
+  let result = line;
+  for (const match of uriMatches) {
+    const [fullMatch, , originalUri] = match;
+    if (originalUri.includes('://') || originalUri.startsWith('/')) {
+      let uri = originalUri;
+      if (variables) {
+        uri = substituteVariables(uri, variables);
+      }
+      const resolvedUrl = resolveUrl(baseUrl, uri);
+      result = result.replace(fullMatch, fullMatch.replace(originalUri, resolvedUrl));
+    }
+  }
+  return result;
+}
