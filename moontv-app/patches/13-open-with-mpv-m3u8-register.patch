diff --git a/src/app/api/m3u8-register/route.ts b/src/app/api/m3u8-register/route.ts
new file mode 100644
index 0000000..f885f89
--- /dev/null
+++ b/src/app/api/m3u8-register/route.ts
@@ -0,0 +1,2 @@
+export const runtime = 'nodejs';
+export { POST } from '@/lib/m3u8.register';
diff --git a/src/app/api/registered.m3u8/route.ts b/src/app/api/registered.m3u8/route.ts
new file mode 100644
index 0000000..b753efe
--- /dev/null
+++ b/src/app/api/registered.m3u8/route.ts
@@ -0,0 +1,2 @@
+export const runtime = 'nodejs';
+export { GET } from '@/lib/m3u8.register';
diff --git a/src/components/UserMenu.tsx b/src/components/UserMenu.tsx
index 2d55278..84493f2 100644
--- a/src/components/UserMenu.tsx
+++ b/src/components/UserMenu.tsx
@@ -127,6 +127,8 @@ export const UserMenu: React.FC = () => {
   }, []);
 
   // ä» localStorage è¯»å–è®¾ç½®
+  // è®¾ç½® m3u8 filter ç›¸å…³çŠ¶æ€. åœ¨æ­¤è¡¥å……æ·»åŠ , æé«˜è¡¥ä¸æˆåŠŸç‡
+  const [mpvM3u8Filter, setMpvM3u8Filter] = useState(true);
   useEffect(() => {
     if (typeof window !== 'undefined') {
       const savedAggregateSearch = localStorage.getItem(
@@ -191,6 +193,13 @@ export const UserMenu: React.FC = () => {
         setFluidSearch(defaultFluidSearch);
       }
 
+      const savedMpvM3u8Filter = localStorage.getItem('mpvM3u8Filter');
+      if (savedMpvM3u8Filter !== null) {
+        setMpvM3u8Filter(JSON.parse(savedMpvM3u8Filter));
+      } else {
+        setMpvM3u8Filter(true); // é»˜è®¤å€¼ä¸º true
+      }
+
       const savedLiveDirectConnect = localStorage.getItem('liveDirectConnect');
       if (savedLiveDirectConnect !== null) {
         setLiveDirectConnect(JSON.parse(savedLiveDirectConnect));
@@ -370,6 +379,13 @@ export const UserMenu: React.FC = () => {
     }
   };
 
+  const handleMpvM3u8FilterToggle = (value: boolean) => {
+    setMpvM3u8Filter(value);
+    if (typeof window !== 'undefined') {
+      localStorage.setItem('mpvM3u8Filter', JSON.stringify(value));
+    }
+  };
+
   const handleLiveDirectConnectToggle = (value: boolean) => {
     setLiveDirectConnect(value);
     if (typeof window !== 'undefined') {
@@ -432,6 +448,7 @@ export const UserMenu: React.FC = () => {
     setDefaultAggregateSearch(true);
     setEnableOptimization(true);
     setFluidSearch(defaultFluidSearch);
+    setMpvM3u8Filter(true);
     setLiveDirectConnect(false);
     setDoubanProxyUrl(defaultDoubanProxy);
     setDoubanDataSource(defaultDoubanProxyType);
@@ -442,6 +459,7 @@ export const UserMenu: React.FC = () => {
       localStorage.setItem('defaultAggregateSearch', JSON.stringify(true));
       localStorage.setItem('enableOptimization', JSON.stringify(true));
       localStorage.setItem('fluidSearch', JSON.stringify(defaultFluidSearch));
+      localStorage.setItem('mpvM3u8Filter', JSON.stringify(true));
       localStorage.setItem('liveDirectConnect', JSON.stringify(false));
       localStorage.setItem('doubanProxyUrl', defaultDoubanProxy);
       localStorage.setItem('doubanDataSource', defaultDoubanProxyType);
@@ -931,6 +949,30 @@ export const UserMenu: React.FC = () => {
               </label>
             </div>
 
+            {/* MPV m3u8 æµå¹¿å‘Šè¿‡æ»¤ */}
+            <div className='flex items-center justify-between'>
+              <div>
+                <h4 className='text-sm font-medium text-gray-700 dark:text-gray-300'>
+                  MPV m3u8 æµå¹¿å‘Šè¿‡æ»¤
+                </h4>
+                <p className='text-xs text-gray-500 dark:text-gray-400 mt-1'>
+                  æ˜¯å¦è¿‡æ»¤ #EXT-X-DISCONTINUITY æ ‡ç­¾ä¹‹é—´çš„ç–‘ä¼¼å¹¿å‘Šå†…å®¹ï¼Œå…³é—­åä»…ç§»é™¤ #EXT-X-DISCONTINUITY æ ‡ç­¾ä»¥ä¿®å¤ mpv çš„æ’­æ”¾æ—¶é—´è½´é—®é¢˜
+                </p>
+              </div>
+              <label className='flex items-center cursor-pointer'>
+                <div className='relative'>
+                  <input
+                    type='checkbox'
+                    className='sr-only peer'
+                    checked={mpvM3u8Filter}
+                    onChange={(e) => handleMpvM3u8FilterToggle(e.target.checked)}
+                  />
+                  <div className='w-11 h-6 bg-gray-300 rounded-full peer-checked:bg-green-500 transition-colors dark:bg-gray-600'></div>
+                  <div className='absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full transition-transform peer-checked:translate-x-5'></div>
+                </div>
+              </label>
+            </div>
+
             {/* ç›´æ’­è§†é¢‘æµè§ˆå™¨ç›´è¿ */}
             <div className='flex items-center justify-between'>
               <div>
diff --git a/src/lib/m3u8.register.ts b/src/lib/m3u8.register.ts
new file mode 100644
index 0000000..d37e529
--- /dev/null
+++ b/src/lib/m3u8.register.ts
@@ -0,0 +1,906 @@
+/* eslint-disable no-console */
+/* Copyright (c) 2025 shmilee*/
+
+import * as http from 'http';
+import * as https from 'https';
+import { NextRequest, NextResponse } from 'next/server';
+
+import { getAuthInfoFromCookie } from '@/lib/auth';
+import { getBaseUrl, resolveUrl } from "@/lib/live";
+
+export const runtime = 'nodejs';
+
+interface responseM3u8Text {
+  ok: boolean;
+  status: number;
+  statusText: string;
+  url: string;
+  textType: string;
+  textLength: number;
+  textLines: string[];
+}
+
+interface m3u8keyEntry {
+  url: string;
+  timestamp: number;
+  responseCache: responseM3u8Text | null;
+}
+
+// register m3u8: key & url
+const registeredKeys = new Map<string, m3u8keyEntry>();
+const EXPIRATION_TIME = 8 * 60 * 60 * 1000; // 8å°æ—¶
+const MAX_ENTRIES = 60; // æ³¨å†Œæ•°é‡ä¸Šé™
+
+// ç”Ÿæˆå”¯ä¸€çš„ä¸´æ—¶ key for url
+export function generateM3u8TempKey(url: string): string {
+  // ä½¿ç”¨ç®€å•çš„å“ˆå¸Œå‡½æ•°å¤„ç† url
+  let hash = 0;
+  for (let i = 0; i < url.length; i++) {
+    const char = url.charCodeAt(i);
+    hash = ((hash << 5) - hash) + char;
+    hash = hash | 0; // Convert to 32bit integer
+  }
+  // timestamp, Xå°æ—¶æ¯«ç§’æ•°å†…ä¸å˜
+  const ts8h = Math.floor(Date.now()/EXPIRATION_TIME);
+  // ç®€å•å“ˆå¸Œ('mpv')=3*7*7*11*67=108339; 8339=31*269
+  const hashstr = (Math.abs(hash)*ts8h*8339).toString(36);
+  return hashstr.length >= 9 ? hashstr.substring(2, 9) : hashstr.substring(0, 7);
+}
+
+// æ£€æŸ¥ URL æ ¼å¼
+function isValidUrl(url: string | null): boolean {
+  if (!url) return false;
+  try {
+    new URL(url);
+    return true;
+  } catch {
+    return false;
+  }
+}
+
+// æ³¨å†Œ key
+function registerM3u8(key: string, url: string): void {
+  const entry: m3u8keyEntry = {
+    url: url,
+    timestamp: Date.now(),
+    responseCache: null,
+  };
+  registeredKeys.set(key, entry);
+  // æ³¨å†Œåç«‹å³æ£€æŸ¥æ•°é‡é™åˆ¶
+  if (registeredKeys.size > MAX_ENTRIES) {
+    // è·å–æœ€æ—§çš„ keyï¼ˆMapä¿æŒæ’å…¥é¡ºåºï¼‰
+    const oldestKey = registeredKeys.keys().next().value;
+    if (oldestKey === undefined) return;
+    console.log(`M3U8: Auto cleanup oldest key ${oldestKey}, after registered ${key}`);
+    registeredKeys.delete(oldestKey);
+  }
+}
+
+// æ¸…ç†è¿‡æœŸæ¡ç›®
+function cleanupExpiredKeys(): void {
+  const now = Date.now();
+  registeredKeys.forEach((entry, key) => {
+    if (now - entry.timestamp > EXPIRATION_TIME) {
+      console.log('M3U8: ğŸ§¹cleanup expired key=', key);
+      registeredKeys.delete(key);
+    }
+  });
+}
+setInterval(cleanupExpiredKeys, 30 * 60 * 1000); // åŠå°æ—¶æ¸…ç†ä¸€æ¬¡
+
+export async function POST(request: NextRequest) {
+  try {
+    // ä» cookie è·å–ç”¨æˆ·ä¿¡æ¯
+    const authInfo = getAuthInfoFromCookie(request);
+    if (!authInfo || !authInfo.username) {
+      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
+    }
+
+    const { key, original_url } = await request.json();
+    // éªŒè¯å‚æ•°
+    if (!key || !original_url) {
+      return NextResponse.json({ success: false, error: 'Missing parameters' }, { status: 400 });
+    }
+    // éªŒè¯ URL
+    if (!isValidUrl(original_url)) {
+      return NextResponse.json({ success: false, error: 'Invalid URL format' }, { status: 400 });
+    }
+    // æ³¨å†Œ
+    registerM3u8(key, original_url);
+    return NextResponse.json({ success: true, expires: EXPIRATION_TIME });
+  } catch (error) {
+    console.error('M3U8 registration error:', error);
+    return NextResponse.json({ success: false, error: 'Invalid request' }, { status: 400 });
+  }
+}
+
+
+// GET: è¿æ¥æ± ç®¡ç†
+const httpsAgent = new https.Agent({
+  keepAlive: true,
+  maxSockets: 50,
+  maxFreeSockets: 10,
+  timeout: 60000,
+  keepAliveMsecs: 30000,
+});
+
+const httpAgent = new http.Agent({
+  keepAlive: true,
+  maxSockets: 50,
+  maxFreeSockets: 10,
+  timeout: 60000,
+  keepAliveMsecs: 30000,
+});
+
+// GET: fetch headers, å‚è€ƒ hls.js fetch-loader
+const fetchHeaders = new Headers({
+  'User-Agent': 'AptvPlayer/1.4.10',
+  'Accept': 'application/vnd.apple.mpegurl, application/x-mpegurl, application/octet-stream, */*',
+  'Accept-Encoding': 'identity', // é¿å…gzipå‹ç¼©å¯¼è‡´çš„å¤„ç†å¤æ‚æ€§
+  'Accept-Language': 'en-US,en;q=0.9',
+  'Cache-Control': 'no-cache',
+  'Pragma': 'no-cache',
+  'Connection': 'keep-alive'
+});
+
+const MAX_RECURSION_DEPTH = 3;
+// GET: fetch m3u8 textLines. ç»“æœå·² trim ä¸”æ— ç©ºè¡Œ.
+async function fetchM3u8Content(url: string, depth: number): Promise<responseM3u8Text> {
+  const responu8: responseM3u8Text = {
+    ok: false, status: 500, statusText: 'not set',
+    url: '', textType: '', textLength: 0, textLines: [],
+  };
+
+  if (depth > MAX_RECURSION_DEPTH) {
+    responu8.statusText = 'Maximum recursion depth exceeded';
+    console.error(`M3U8: ${responu8.statusText}`);
+    return responu8;
+  }
+
+  let response: Response | null = null;
+  let responseUsed = false;
+  const controller = new AbortController();
+  const timeoutId = setTimeout(() => controller.abort(), 17000); // 17ç§’è¶…æ—¶
+  const agent = url.startsWith('https:') ? httpsAgent : httpAgent; // é€‰æ‹© agent
+  try {
+    console.log(`M3U8: è·å–æ’­æ”¾åˆ—è¡¨ ${url}`);
+    response = await fetch(url, {
+      cache: 'no-cache',
+      redirect: 'follow',
+      credentials: 'same-origin',
+      signal: controller.signal,
+      headers: fetchHeaders,
+      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+      // @ts-ignore - Node.js specific option
+      agent: typeof window === 'undefined' ? agent : undefined,
+    });
+    clearTimeout(timeoutId);
+    responu8.ok = response.ok;
+    responu8.status = response.status;
+    responu8.statusText = response.statusText;
+    if (response.ok) {
+      // è·å–æœ€ç»ˆçš„å“åº”URLï¼ˆå¤„ç†é‡å®šå‘åçš„URLï¼‰
+      responu8.url = response.url;
+      // æ£€æŸ¥å†…å®¹æ˜¯å¦ä¸º M3U8
+      responu8.textType = response.headers.get('Content-Type') || '';
+      const isM3U8 = responu8.textType.toLowerCase().includes('mpegurl') ||
+                     responu8.textType.toLowerCase().includes('octet-stream') ||
+                     url.includes('.m3u8');
+      if (isM3U8) {
+        console.log(`M3U8: æ£€æŸ¥æ’­æ”¾åˆ—è¡¨ ${responu8.url}`);
+        const m3u8Content = await response.text();
+        responseUsed = true;
+        responu8.textLength = parseInt(response.headers.get('Content-Length') || '0', 10);
+        if (responu8.textLength === 0) {
+          responu8.textLength = m3u8Content.length;
+        }
+        responu8.textLines = m3u8Content.split('\n')
+            .map(line => line.trim())
+            .filter(Boolean);  // ä½¿ç”¨ Boolean è¿‡æ»¤ç©ºè¡Œ
+        // æ£€æŸ¥åªåŒ…å«ä¸€è¡Œ #EXT-X-STREAM-INF å’Œä¸€è¡Œ /xx/XXXX.m3u8?p=1 çš„å­ m3u8
+        const nonCommentLines = responu8.textLines.filter(line => !line.startsWith('#'));
+        const m3u8LineIndex = responu8.textLines.findIndex(line => !line.startsWith('#') && /\.m3u8(\?|$)/.test(line));
+        if (nonCommentLines.length === 1 && m3u8LineIndex > 0
+            &&  responu8.textLines[m3u8LineIndex - 1].startsWith('#EXT-X-STREAM-INF')) {
+          // ä½¿ç”¨æœ€ç»ˆçš„å“åº” URL ä½œä¸º baseUrl å’Œå­ /xx/XXXX.m3u8 ç»„åˆåé‡æ–°è¯·æ±‚
+          const baseUrl = getBaseUrl(responu8.url);
+          const resolvedUrl = resolveUrl(baseUrl, responu8.textLines[m3u8LineIndex]);
+          console.log(`M3U8: æ£€æµ‹åˆ°ä¸»æ’­æ”¾åˆ—è¡¨, åˆ‡æ¢åˆ°å­æ’­æ”¾åˆ—è¡¨ ${resolvedUrl}`);
+          const responu88 = await fetchM3u8Content(resolvedUrl, depth + 1);
+          if (responu88.ok) {
+            return responu88;
+          } else {
+            console.error(`M3U8: åˆ‡æ¢å­æ’­æ”¾åˆ—è¡¨ ${resolvedUrl} å¤±è´¥ï¼Œä»ç”¨åŸå§‹ URL!`);
+          }
+        }
+      } else {
+        responu8.ok = false;
+        responu8.status = 415;
+        responu8.statusText = `Non-M3U8 Content-Type: ${responu8.textType}`;
+      }
+    }
+  } catch (error) {
+    clearTimeout(timeoutId);
+    // error instanceof Error, å°è¯•æ¥å—è‡ªç­¾è¯ä¹¦
+    const code = (error as any).cause?.code;
+    if (url.startsWith('https:') && (
+        code === 'SELF_SIGNED_CERT_IN_CHAIN' ||
+        code === 'UNABLE_TO_GET_ISSUER_CERT_LOCALLY')
+       ) {
+      if (code === 'SELF_SIGNED_CERT_IN_CHAIN') {
+        console.warn(`M3U8: æ£€æµ‹åˆ°è‡ªç­¾åè¯ä¹¦ (${code})ï¼Œå°è¯•ä»¥ä¸å®‰å…¨æ–¹å¼é‡æ–°è¯·æ±‚`);
+      } else if (code === 'UNABLE_TO_GET_ISSUER_CERT_LOCALLY') {
+        console.warn(`M3U8: æ£€æµ‹åˆ°æ— æ•ˆè¯ä¹¦é“¾ (${code})ï¼Œå¯èƒ½ç¼ºå¤±æ ¹è¯ä¹¦ï¼Œå°è¯•ä»¥ä¸å®‰å…¨æ–¹å¼é‡æ–°è¯·æ±‚`);
+      }
+      process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
+      const responu88 = await fetchM3u8Content(url, depth + 1);
+      process.env.NODE_TLS_REJECT_UNAUTHORIZED = undefined;
+      if (responu88.ok) {
+        return responu88;
+      } else {
+        console.error(`M3U8: æ¥å—æ— æ•ˆ/è‡ªç­¾åè¯ä¹¦çš„å°è¯•å¤±è´¥!`);
+      }
+    }
+    console.error('M3U8: fetch error,', error);
+    responu8.ok = false;
+    responu8.status = 500;
+    responu8.statusText = `Fetch error, ${error}`;
+  } finally {
+    clearTimeout(timeoutId);
+    // ç¡®ä¿ response è¢«æ­£ç¡®å…³é—­ä»¥é‡Šæ”¾èµ„æº
+    if (response && !responseUsed && response.body) {
+      try {
+        const reader = response.body.getReader();
+        await reader.cancel();
+      } catch (error) {
+        console.warn('M3U8: Failed to close response body:', error);
+      }
+    }
+  }
+
+  return responu8;
+}
+
+// fetchM3u8Content è¯·æ±‚é”ï¼šé¿å…å¯¹åŒä¸€URLåŒæ—¶å‘èµ·å¤šä¸ªè¯·æ±‚
+interface PendingRequest {
+  promise: Promise<responseM3u8Text>;
+  timestamp: number;
+  url: string;
+  requestCount: number;
+}
+
+const pendingRequests = new Map<string, PendingRequest>();
+const PENDING_REQUEST_TIMEOUT = 30000; // 30ç§’è¶…æ—¶ï¼Œé˜²æ­¢æŒ‚èµ·çš„è¯·æ±‚æ°¸è¿œä¸æ¸…ç†
+
+// æ¸…ç†è¿‡æœŸçš„æŒ‚èµ·è¯·æ±‚
+function cleanupPendingRequests(): void {
+  const now = Date.now();
+  pendingRequests.forEach((request, key) => {
+    if (now - request.timestamp > PENDING_REQUEST_TIMEOUT) {
+      console.log(`M3U8: ğŸ§¹æ¸…ç†è¶…æ—¶çš„æŒ‚èµ·è¯·æ±‚: key=${key}, url=${request.url}`);
+      pendingRequests.delete(key);
+    }
+  });
+}
+// æ¯åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡
+setInterval(cleanupPendingRequests, 60000);
+
+// fetchM3u8Content å¤„ç†è¯·æ±‚å»é‡
+async function fetchM3u8ContentWithDeduplication(key: string, url: string, depth: number): Promise<responseM3u8Text> {
+  const fetchStartTime = Date.now();
+  // æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒçš„è¯·æ±‚æ­£åœ¨è¿›è¡Œä¸­
+  const existingRequest = pendingRequests.get(key);
+  if (existingRequest) {
+    console.log(`M3U8: â³Waiting for existing ${existingRequest.requestCount} request(s) for key=${key}`);
+    existingRequest.requestCount++; // å¢åŠ ç­‰å¾…è®¡æ•°
+    const responu8: responseM3u8Text = await existingRequest.promise;
+    const duration = Date.now() - fetchStartTime;
+    if (responu8 && responu8.ok) {
+      console.log(`M3U8: ğŸ’«Use fetched cache after waiting request ${responu8.textLength} Bytes for key=${key} in ${duration}ms`);
+      return responu8;
+    // 403, 404: do not retry
+    } else if (responu8 && (responu8.status === 403 || responu8.status === 404)) {
+      console.log(`M3U8: ğŸ’«Use fetched cache '${responu8.status} ${responu8.statusText}' after waiting for key=${key} in ${duration}ms`);
+      return responu8;
+    } else {
+      console.log(`M3U8: âŒWaiting request failed for key=${key}  in ${duration}ms`);
+    }
+  }
+  // æ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„è¯·æ±‚ æˆ–ç­‰å¾…çš„è¯·æ±‚å¤±è´¥
+  console.log(`M3U8: ğŸš€Fetching source for key=${key}, url=${url} ...`);
+  const promise = fetchM3u8Content(url, depth);
+  // å­˜å‚¨åˆ°æŒ‚èµ·è¯·æ±‚Mapä¸­
+  pendingRequests.set(key, {
+    promise, timestamp: Date.now(),
+    url, requestCount: 1,
+  });
+  const responu8: responseM3u8Text = await promise;
+  const duration = Date.now() - fetchStartTime;
+  const entry = registeredKeys.get(key);
+  if (responu8 && responu8.ok) {
+    console.log(`M3U8: âœ…Fetch ${responu8.textLength} Bytes for key=${key} in ${duration}ms`);
+    // fetch æˆåŠŸåï¼Œæ›´æ–°é•¿æœŸ cache
+    if (entry) {
+      console.log(`M3U8: ğŸ’«Set fetched cache for key=${key}`);
+      entry.responseCache = responu8;
+    }
+  } else {
+    console.log(`M3U8: âFetch 0 Bytes for key=${key} in ${duration}ms, âŒï¸ ${responu8.status} ${responu8.statusText}`);
+    // 403, 404: åŒæ ·æ›´æ–°é•¿æœŸ cache
+    if (entry && (responu8.status === 403 || responu8.status === 404)) {
+      console.log(`M3U8: ğŸ’«Set fetched cache 'âŒï¸ ${responu8.status} ${responu8.statusText}' for key=${key}`);
+      entry.responseCache = responu8;
+    }
+  }
+  // ç¡®ä¿ä»æŒ‚èµ·è¯·æ±‚ä¸­ç§»é™¤
+  try {
+    return responu8;
+  } finally {
+    pendingRequests.delete(key);
+  }
+}
+
+// GET: æ€§èƒ½ç»Ÿè®¡
+const stats = {
+  requests: 0,
+  errors: 0,
+  avgResponseTime: 0,
+  totalBytes: 0,
+};
+
+// GET: ç®€å•çš„é¢‘ç‡é™åˆ¶ - åªè®°å½•æ¯ä¸ªIPçš„æœ€åè¯·æ±‚æ—¶é—´å’Œç´¯è®¡æ¬¡æ•°
+const lastRequestTime = new Map<string, [number, number]>();
+// 5ç§’æœ€å°é—´éš”ï¼Œæ¯éš”3æ¬¡è¯·æ±‚æ£€æŸ¥ï¼ˆæ–¹ä¾¿ mpv è¿ç»­å¤š(2,5?)æ¬¡è®¿é—®ï¼‰
+const MIN_REQUEST_INTERVAL = [5000, 4];
+// æ¸…ç†é•¿æ—¶é—´æœªæ´»åŠ¨çš„IPè®°å½•ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
+function cleanupOldRequestTimes(): void {
+  const now = Date.now();
+  lastRequestTime.forEach(([timestamp, ], ip) => {
+    if (now - timestamp > 1800000) {
+      lastRequestTime.delete(ip);
+    }
+  });
+}
+// åŠå°æ—¶æ¸…ç†ä¸€æ¬¡
+setInterval(cleanupOldRequestTimes, 1800000);
+
+// GET: ç®€å•çš„ 10*MIN_REQUEST_INTERVAL[0] æ¯«ç§’ modifiedContent ç¼“å­˜å®ç°
+// æ­¤å¤„ key ç”± registered url key å’Œ filter: on, off æ‹¼æ¥è€Œæˆ
+const modifiedContentCache = new Map<string, {value: string, timeoutId: NodeJS.Timeout}>();
+function setModifiedContentCache(key: string, value: string) {
+  // å¦‚æœå·²å­˜åœ¨ç›¸åŒçš„keyï¼Œå…ˆæ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
+  const entry = modifiedContentCache.get(key);
+  if (entry && entry.timeoutId) {
+    clearTimeout(entry.timeoutId);
+  }
+  // è®¾ç½® X ç§’ååˆ é™¤ entry ä»¥åŠ entry.timeoutId clears itself automatically.
+  const timeoutId = setTimeout(() => {
+    modifiedContentCache.delete(key);
+    console.log(`M3U8: ğŸ§¹key='${key}' çš„ filtered & modified ç¼“å­˜ï¼ˆå³ modifiedContentï¼‰å·²æ¸…ç†`);
+  }, Math.max(1000, MIN_REQUEST_INTERVAL[0]*10));
+
+  // å­˜å‚¨å€¼å’Œå®šæ—¶å™¨ID
+  modifiedContentCache.set(key, {
+    value,
+    timeoutId,
+  });
+}
+
+// Ref: https://github.com/SzeMeng76/LunaTV/blob/main/src/app/api/proxy/m3u8/route.ts
+// "ä¸"éªŒè¯ç”¨æˆ·ä¿¡æ¯ï¼Œæ–¹ä¾¿ mpv è®¿é—®ï¼Œä½†é™åˆ¶è¯·æ±‚é¢‘ç‡
+//  /api/registered.m3u8?key=xx&filter=xx æˆ– /api/registered.m3u8?filter=xx&token=xxx&url=xx
+//  key: registered url key
+//  url: any m3u8 source url, need token
+//  token: NEXT_PUBLIC_M3U8_URL_TOKEN, set by admin
+//  filter: on, off
+//    on: filter #EXT-X-DISCONTINUITY adjump ad.ts etc.
+//    off: only delete #EXT-X-DISCONTINUITY tag
+export async function GET(request: NextRequest) {
+  const startTime = Date.now();
+  stats.requests++;
+  const { searchParams } = new URL(request.url);
+  let key = searchParams.get('key');
+  const url = searchParams.get('url');
+  const token = searchParams.get('token');  
+  let filter = searchParams.get('filter');
+  // è·å–å®¢æˆ·ç«¯IPï¼Œæ£€æŸ¥è¯·æ±‚é—´éš”
+  let clientIP = request.headers.get('x-forwarded-for');
+  if (clientIP) {
+    // x-forwarded-for å¯åŒ…å«å¤šä¸ª IPï¼Œç¬¬ä¸€ä¸ªæ˜¯ client
+    clientIP = clientIP.split(',')[0].trim();
+  }
+  if (!clientIP) {
+    clientIP = request.headers.get('x-real-ip') ||
+               request.headers.get('cf-connecting-ip') ||
+               'unknown';
+  }
+  console.log('------------------------------');
+  console.log(`M3U8: ğŸŒGET Request from IP: ${clientIP}, ğŸ¯Referer: ${request.headers.get('referer') || 'direct'}`);
+  console.log(`M3U8: ğŸ“±User-Agent: ${request.headers.get('user-agent') || 'unknown'}`);
+
+  try {
+    // è¯·æ±‚é¢‘ç‡é™åˆ¶
+    const [lastTime, clcount] = lastRequestTime.get(clientIP) || [null, 0];
+    if (lastTime && (startTime - lastTime) < MIN_REQUEST_INTERVAL[0]) {
+      if (clcount % MIN_REQUEST_INTERVAL[1] === 0) {
+        stats.errors++;
+        return new Response(`Too Many Requests - Please wait at least ${MIN_REQUEST_INTERVAL[0]/1000} seconds between requests`, {
+          status: 429, headers: { 'Retry-After': `${MIN_REQUEST_INTERVAL[0]/1000}` }
+        });
+      }
+      // æ›´æ–°æœ€åè¯·æ±‚æ—¶é—´å’Œç´¯è®¡æ¬¡æ•°
+      lastRequestTime.set(clientIP, [startTime, clcount+1]);
+    } else {
+      // å¤§äºæœ€å°é—´éš”åï¼Œé‡ç½®ç´¯è®¡æ¬¡æ•°
+      lastRequestTime.set(clientIP, [startTime, 1]);
+    }
+
+    // è¯·æ±‚å‚æ•°æ£€æŸ¥
+    if (key && url) {
+      stats.errors++;
+      return new Response('Too many parameters: url & key', { status: 400 });
+    }
+    if (key) {
+        if (!registeredKeys.has(key)) {
+          stats.errors++;
+          return new Response('Not Found m3u8 key', { status: 404 });
+        }
+    } else if (url) {
+      if (!process.env.NEXT_PUBLIC_M3U8_URL_TOKEN) {
+        stats.errors++;
+        return new Response('Unsupported parameter: url', { status: 400 });
+      }
+      if (!token) {
+        stats.errors++;
+        return new Response('Missing required parameter: token', { status: 400 });
+      }
+      if (process.env.NEXT_PUBLIC_M3U8_URL_TOKEN !== token) {
+        stats.errors++;
+        return new Response('Invalid token', { status: 400 });
+      }
+      // éªŒè¯ URL
+      if (!isValidUrl(url)) {
+        stats.errors++;
+        return new Response('Invalid URL format', { status: 400 });
+      }
+      key = generateM3u8TempKey(url);
+      // ä¸å­˜åœ¨åˆ™æ³¨å†Œ
+      if (!registeredKeys.has(key)) {
+        registerM3u8(key, url);
+      }
+    } else {
+      stats.errors++;
+      return new Response('Missing required parameters: url or key', { status: 400 });
+    }
+    // è·å–å·²æ³¨å†Œçš„ key
+    const entry = registeredKeys.get(key);
+    if (!entry) {
+      stats.errors++;
+      return new Response('Not Found m3u8 entry', { status: 400 });
+    }
+    if (!entry.url) {
+      stats.errors++;
+      return new Response('Broken m3u8 entry', { status: 400 });
+    }
+    // æ£€æŸ¥è¿‡æ»¤å‚æ•°
+    if (!filter || !(filter === 'off' || filter === 'on')) {
+      filter = 'on';
+    }
+
+    // ä½¿ç”¨ entry.url è·å–åŸå§‹ m3u8 å†…å®¹
+    const decodedUrl = decodeURIComponent(entry.url);
+    let responu8: responseM3u8Text | null =  null;
+    if (entry.responseCache) {
+      responu8 = entry.responseCache;
+      const ttl = Math.max(0, entry.timestamp + EXPIRATION_TIME - Date.now());
+      if (responu8.ok) {
+        console.log(`M3U8: ğŸ’«Find fetched cache ${(responu8.textLength / 1024).toFixed(1)}KB for key=${key}, cache ttl=${secondsToHMS(ttl/1000)}`);
+      } else { // 403, 404 cache
+        console.log(`M3U8: ğŸ’«Find fetched cache 'âŒï¸ ${responu8.status} ${responu8.statusText}' for key=${key}, cache ttl=${secondsToHMS(ttl/1000)}`);
+      }
+    } else {
+      responu8 = await fetchM3u8ContentWithDeduplication(key, decodedUrl, 1);
+    }
+    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
+    stats.totalBytes += responu8?.textLength || 0;
+    // å‚è€ƒ hls.js fetch-loader çš„é”™è¯¯å¤„ç†é€»è¾‘
+    if (!responu8 || !responu8.ok) {
+      stats.errors++;
+      // ç›´æ¥è¿”å›åŸå§‹çš„ HTTP é”™è¯¯ï¼Œè®© mpv å¤„ç†
+      // ä¸è¿”å›JSONï¼Œå› ä¸º mpv æœŸæœ›çš„æ˜¯M3U8å†…å®¹æˆ–æ ‡å‡† HTTP é”™è¯¯
+      const err = `HTTP Error ${responu8?.status}: ${responu8?.statusText}`;
+      return new NextResponse(err, {
+        status: responu8?.status,
+        statusText: responu8?.statusText,
+        headers: {
+          'Content-Type': 'text/plain',
+          'Access-Control-Allow-Origin': '*',
+        }
+      });
+    }
+
+    // è¿‡æ»¤ã€é‡å†™åŸå§‹ M3U8 å†…å®¹
+    const filterStartTime = Date.now();
+    let duration: number | null = null;
+    const contentCache: string | null = modifiedContentCache.get(`${key}:filter=${filter}`)?.value || null;
+    let modifiedContent: string | null = null;
+    if (contentCache) {
+        modifiedContent = contentCache;
+        duration = Date.now() - filterStartTime;
+        console.log(`M3U8: ğŸ’«Find filtered & modified cache for key=${key}`);
+    } else {
+      let filterLines: string[] = responu8.textLines;
+      const originalLength = filterLines.length;
+      const discontinuityFirstIndex = filterLines.indexOf('#EXT-X-DISCONTINUITY');
+      if (discontinuityFirstIndex === -1) {
+        duration = Date.now() - filterStartTime;
+        console.log(`M3U8: âœ…æ²¡æœ‰ DISCONTINUITY æ ‡ç­¾ï¼Œæ— éœ€è¿‡æ»¤æ¸…ç†ï¼Œdone in ${duration}ms`);
+      } else {
+        if (filter === 'on') {
+          // on: è¿‡æ»¤ #EXT-X-DISCONTINUITY ä»¥åŠç–‘ä¼¼å¹¿å‘Š adjump ç­‰
+          console.log('M3U8: ğŸ”„Aggressive filter (DISCONTINUITY + ads)');
+          filterLines = filterDiscontinuityAdJump(filterLines);
+        } else if (filter === 'off') {
+          // off: ä»…è¿‡æ»¤ #EXT-X-DISCONTINUITY æ ‡ç­¾
+          console.log('M3U8: ğŸ”„Basic filter (DISCONTINUITY only)');
+          filterLines = filterLines.filter(line => !line.startsWith('#EXT-X-DISCONTINUITY'));
+        }
+        const removedCount = originalLength - filterLines.length;
+        duration = Date.now() - filterStartTime;
+        console.log(`M3U8: âœ…Filtered ${removedCount}/${originalLength} lines in ${duration}ms`);
+      }
+      // åˆ‡ç‰‡ã€URI ç­‰æ›´æ–°ä¸ºç»å¯¹åœ°å€, ä½¿ç”¨æœ€ç»ˆçš„å“åº” URL è·å– baseUrl
+      const baseUrl = getBaseUrl(responu8.url);
+      const rewriteStartTime = Date.now();
+      modifiedContent = rewriteM3U8Content(filterLines, baseUrl);
+      duration = Date.now() - rewriteStartTime;
+      console.log(`M3U8: âœ…Modified ${filterLines.length} lines in ${duration}ms`);
+      // è¿‡æ»¤ã€é‡å†™å®Œæˆåï¼Œæ›´æ–°çŸ­æœŸ cache
+      console.log(`M3U8: ğŸ’«Set filtered & modified cache for key=${key}:filter=${filter}`);
+      setModifiedContentCache(`${key}:filter=${filter}`, modifiedContent);
+    }
+
+    const resHeaders = new Headers({
+      'Content-Type': responu8.textType || 'application/vnd.apple.mpegurl',
+      'Access-Control-Allow-Origin': '*',
+      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS, HEAD',
+      'Access-Control-Allow-Headers': 'Content-Type, Range, Origin, Accept, User-Agent',
+      'Cache-Control': 'no-cache, no-store, must-revalidate',
+      'Pragma': 'no-cache',
+      'Expires': '0',
+      'Access-Control-Expose-Headers': 'Content-Length, Content-Range, Content-Type',
+      'Content-Length': modifiedContent.length.toString(),
+    });
+    return new Response(modifiedContent, { headers: resHeaders, status: 200 });
+  } catch (error) {
+    stats.errors++;
+    console.error('M3U8: âŒï¸filter error:', error);
+    return new Response(`M3U8 filter error: ${error}`, { status: 500 });
+  } finally {
+    // æ›´æ–°æ€§èƒ½ç»Ÿè®¡
+    const responseTime = Date.now() - startTime;
+    console.log(`M3U8: âœ…Response for IP ${clientIP} in ${responseTime}ms`);
+    stats.avgResponseTime = (stats.avgResponseTime * (stats.requests - 1) + responseTime) / stats.requests;
+    const totalM3u8TextCache = Array.from(registeredKeys.values()).reduce((sum, entry) => sum + (entry.responseCache?.textLength || 0), 0);
+    // å®šæœŸæ‰“å°ç»Ÿè®¡ä¿¡æ¯
+    //if (stats.requests % 10 === 0 && process.env.NODE_ENV === 'development') {
+    console.log(`M3U8: ğŸ“ˆFilter Stats - Requests: ${stats.requests}, Errors: ${stats.errors}, Avg Response Time: ${stats.avgResponseTime.toFixed(1)}ms`);
+    console.log(`M3U8: ğŸ“ˆFilter Stats - Total Bytes: ${(stats.totalBytes / 1024).toFixed(1)}KB, Cached Bytes: ${(totalM3u8TextCache / 1024).toFixed(1)}KB`);
+    //}
+  }
+}
+
+function filterDiscontinuityAdJump(lines: string[]): string[] {
+  const result: string[] = [];
+  // 1. ç»Ÿè®¡æ‰€æœ‰ #EXT-X-DISCONTINUITY è¡Œçš„ç´¢å¼•ï¼Œä»¥åŠ é#å¼€å¤´ è¡Œçš„ç›®å½•é¢‘æ¬¡
+  const discontinuityIndexes: number[] = [];
+  const lineDirCount = new Map<string, number>();
+  let firstExtinfIndex = 0; // è®°å½•ç¬¬ä¸€ä¸ªåˆ‡ç‰‡çš„ç´¢å¼•
+  for (let i = 0; i < lines.length; i++) {
+    if (lines[i] === '#EXT-X-DISCONTINUITY') {
+      discontinuityIndexes.push(i);
+    } else if (firstExtinfIndex === 0 && lines[i].startsWith('#EXTINF:')) {
+      firstExtinfIndex = i;
+    } else if (!lines[i].startsWith('#')) {
+      const dir = lines[i].substring(0, lines[i].lastIndexOf('/') + 1);
+      lineDirCount.set(dir, (lineDirCount.get(dir) || 0) + 1);
+    }
+  }
+  const totalCount = Array.from(lineDirCount.values()).reduce((sum, count) => sum + count, 0);
+  const lineDirPercentage = new Map(
+    Array.from(lineDirCount.entries())
+      .map(([dir, count]): [string, number] => [dir, count / totalCount * 100])
+      .sort((a, b) => a[1] - b[1])
+  );
+  // DEBUG ç»Ÿè®¡ç»“æœ
+  console.log(`M3U8: æ‰¾åˆ° ${discontinuityIndexes.length} ä¸ª #EXT-X-DISCONTINUITY æ ‡ç­¾, ç´¢å¼•ä½ç½®:`, discontinuityIndexes);
+  console.log('M3U8: ç›®å½•é¢‘æ¬¡ç™¾åˆ†æ¯”ï¼ˆå‡åºï¼‰:');
+  let rank = 1;
+  lineDirPercentage.forEach((percentage, dir) => {
+    console.log(`M3U8:   â†’ ${rank}) ${percentage.toFixed(2)}% : '${dir}'`);
+    rank++;
+  });
+
+  // 2. æ·»åŠ å¼€å¤´çš„ #EXTM3U è‡³ ç¬¬1ä¸ªåˆ‡ç‰‡å‰çš„å†…å®¹ï¼ˆæˆ– discontinuityIndexes[0] ä¹‹å‰çš„å†…å®¹ï¼‰
+  // re-check ç¬¬ä¸€è¡Œçš„ #EXTM3U
+  if (lines[0] !== '#EXTM3U') {
+    result.push('#EXTM3U');
+  }
+  const headIndex = Math.min(firstExtinfIndex, discontinuityIndexes[0])
+  console.log(`M3U8: ğŸŸ¢å¤åˆ¶ Head: (ç´¢å¼• 0-${headIndex-1}, å…±å¤åˆ¶ ${headIndex} è¡Œ)`);
+  for (let i = 0; i < headIndex; i++) {
+    result.push(lines[i]);
+  }
+  // è®°å½•æ€»æ—¶é•¿ å’Œ å·²ä¿ç•™åˆ‡ç‰‡çš„æ—¶é•¿, ç§’
+  let totalTime = 0;
+  let keepTime = 0;
+
+  // 3. æŒ‰ #EXT-X-DISCONTINUITY ç´¢å¼•åˆ†ç»„. Videoã€Ad ç»„äº¤æ›¿å‡ºç°
+  // é‡æ–°è®¾ç½® #EXT-X-KEY çš„è¡Œä¸éœ€å¤„ç†ï¼Œä¸åˆ é™¤æ— å½±å“
+  // å¯èƒ½éœ€ä»ä¸å­˜åœ¨çš„ j=-1 å¼€å§‹ï¼Œå¤„ç†å¯èƒ½å­˜åœ¨çš„ discontinuityIndexes[0] ä¹‹å‰çš„å†…å®¹ï¼Œå³ç¬¬ 0 ç»„
+  const jStart = firstExtinfIndex < discontinuityIndexes[0] ? -1 : 0;
+  for (let j = jStart; j < discontinuityIndexes.length; j++) {
+    // å®šä½å½“å‰ç»„
+    // ä»å½“å‰ DISCONTINUITY åˆ°ä¸‹ä¸€ä¸ª DISCONTINUITY æˆ–æ–‡ä»¶ç»“æŸï¼Œä»…åŒ…å«ç»„èµ·å§‹çš„ #EXT-X-DISCONTINUITY æ ‡ç­¾
+    // æˆ– discontinuityIndexes[0] ä¹‹å‰çš„åˆ‡ç‰‡å†…å®¹ï¼ˆä¸å« discontinuityIndexes[0]ï¼‰
+    const discIndex = j === -1 ? firstExtinfIndex : discontinuityIndexes[j];
+    const nextDiscIndex = j + 1 < discontinuityIndexes.length ? discontinuityIndexes[j + 1] : lines.length;
+    // æå–å½“å‰ç»„
+    const currentGroup = lines.slice(discIndex, nextDiscIndex);
+    const currentGroupTime = sumGroupTime(currentGroup);
+    console.log(`M3U8: ğŸ•—ï¸æ£€æµ‹ç¬¬ ${j+1} ç»„, æ—¶é•¿${secondsToHMS(currentGroupTime)}, å§‹äº${secondsToHMS(totalTime)}, ç°å§‹äº${secondsToHMS(keepTime)}`);
+    totalTime += currentGroupTime;
+    // åˆ¤æ–­æ˜¯å¦éœ€è¦è¿‡æ»¤
+    if (skipDiscontinuityGroup(currentGroup, lineDirPercentage)) { // Ad ç»„
+      console.log(`M3U8: ğŸ”´è¿‡æ»¤ç¬¬ ${j+1} ç»„, Ad: (ç´¢å¼• ${discIndex}-${nextDiscIndex-1}), å…±åˆ é™¤ ${currentGroup.length} è¡Œ`);
+    } else {
+      console.log(`M3U8: ğŸŸ¢ä¿ç•™ç¬¬ ${j+1} ç»„, Video: (ç´¢å¼• ${discIndex}-${nextDiscIndex-1}), å…±å¤åˆ¶ ${currentGroup.length}${j===-1?'':'-1'} è¡Œ`);
+      for (let i = (j === -1 ? discIndex : discIndex + 1); i < nextDiscIndex; i++) { // æ³¨æ„ j!==-1 æ—¶ï¼Œé¡»è·³è¿‡ #EXT-X-DISCONTINUITY æ ‡ç­¾
+        if (i < lines.length) {
+          result.push(lines[i]);
+        } else {
+          console.warn(`M3U8: ç´¢å¼• ${i} è¶…å‡ºèŒƒå›´ 0-${lines.length-1}`);
+        }
+      }
+      keepTime += currentGroupTime;
+    }
+  }
+  // re-check æœ€åä¸€è¡Œçš„ #EXT-X-ENDLIST
+  if (result[result.length - 1] !== '#EXT-X-ENDLIST') {
+    result.push('#EXT-X-ENDLIST');
+  }
+
+  return result;
+}
+
+function sumGroupTime(group: string[]): number {
+  const sumTime = group.reduce((sum, line) => {
+    const match = line.match(/^#EXTINF:([\d.]+)/); // æ—¶é—´æ•°å­—ï¼ˆåŒ…æ‹¬å°æ•°ï¼‰
+    return match ? sum + parseFloat(match[1]) : sum;
+  }, 0);
+  return sumTime;
+}
+
+function secondsToHMS(seconds: number): string {
+    const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
+    const m = Math.floor(seconds % 3600 / 60).toString().padStart(2, '0');
+    const s = Math.floor(seconds % 60).toString().padStart(2, '0');
+    return `${h}:${m}:${s}`;
+}
+
+function skipDiscontinuityGroup(
+  group: string[], 
+  dirPercentage: Map<string, number>
+): boolean {
+  // æå–ç»„ä¸­çš„æ‰€æœ‰ URL è¡Œ
+  const urlLines = group.filter(line => !line.startsWith('#'));
+  if (urlLines.length === 0) return false; // æ—  URL è¡Œï¼Œå¯èƒ½æ˜¯çº¯æ ‡ç­¾ç»„ï¼Œä¿ç•™
+
+  // 1. æ£€æŸ¥æ˜ç¡®çš„å¹¿å‘Šç‰¹å¾
+  const hasExplicitAdIndicators = urlLines.some(url =>
+    url.includes('/adjump/') ||
+    url.includes('/ad/') ||
+    url.toLowerCase().includes('advertisement')
+  );
+  if (hasExplicitAdIndicators) {
+    console.log("M3U8:   â†’ å¹¿å‘Šç‰¹å¾: æœ‰æ˜ç¡®ç‰¹å¾, å¦‚ '/adjump/' ç­‰");
+    return true;
+  } else {
+    console.log(`M3U8:   â†’ å¹¿å‘Šç‰¹å¾: æ—  '/adjump/' ç­‰`);
+  }
+
+  // 2. æ£€æŸ¥ç›®å½•é¢‘æ¬¡ï¼ˆä½é¢‘ç›®å½•å¾ˆå¯èƒ½æ˜¯å¹¿å‘Šï¼‰
+  const discDirs: string[] = [];
+  for (const urlLine of urlLines) {
+    const dir = urlLine.substring(0, urlLine.lastIndexOf('/') + 1);
+    if (!discDirs.includes(dir)) {
+      discDirs.push(dir);
+    }
+  }
+  let lowFreqSum = 0;
+  discDirs.forEach((dir) => {
+    const percentage = dirPercentage.get(dir);
+    if (percentage !== undefined) {
+      lowFreqSum += percentage;
+      console.log(`M3U8:   â†’ ç›®å½•é¢‘æ¬¡: '${dir}' (${percentage.toFixed(2)}%)`);
+    } else {
+      console.log(`M3U8:   â†’ ç›®å½•é¢‘æ¬¡: '${dir}' (ä¸¢å¤± percentageï¼ï¼ï¼)`);
+    }
+  });
+  // å¦‚æœç»„ä¸­çš„ URL ç›®å½•æ€»é¢‘æ¬¡ä½äº 3%ï¼Œè®¤ä¸ºå‡æ˜¯å¹¿å‘Šç›®å½•ï¼Œè¿‡æ»¤æ•´ä¸ªç»„
+  if (discDirs.length > 0 && lowFreqSum < 3) {
+    console.log(`M3U8:   â†’ ç›®å½•é¢‘æ¬¡: åˆ¤æ–­ä¸ºä½é¢‘ç›®å½•ç»„, ç–‘ä¼¼å¹¿å‘Š, æ€»é¢‘æ¬¡=${lowFreqSum.toFixed(2)}% < 3%`);
+    return true;
+  }
+  // ä»…2æ¡ç›®å½•é¢‘æ¬¡è®°å½•ï¼Œä¸”æœ¬ç»„ç›®å½•æ€»é¢‘æ¬¡ä½äº (1-0.618)*æœ€å¤§å€¼ï¼Œå³27.64
+  if (dirPercentage.size === 2 && lowFreqSum < 27.64) {
+    const maxFreq = Array.from(dirPercentage.values())[1];
+    console.log(`M3U8:   â†’ ç›®å½•é¢‘æ¬¡: åˆ¤æ–­ä¸ºä½é¢‘ç›®å½•ç»„, ç–‘ä¼¼å¹¿å‘Š, æ€»é¢‘æ¬¡=${lowFreqSum.toFixed(2)}% < (1-0.618)*${maxFreq.toFixed(2)}%`);
+    return true;
+  }
+
+  // 3. æ£€æŸ¥ç»„é•¿åº¦ï¼ˆå¹¿å‘Šæ®µé€šå¸¸è¾ƒçŸ­ï¼‰
+  if (urlLines.length < 8 && group.length < 17) {
+    console.log(`M3U8:   â†’ æœ¬ç»„é•¿åº¦: è¿‡çŸ­, ç–‘ä¼¼å¹¿å‘Š, (${urlLines.length}<8, ${group.length}<17)`);
+    return true;
+  } else {
+    console.log(`M3U8:   â†’ æœ¬ç»„é•¿åº¦: åˆ¤æ–­ä¸ºæ­£å¸¸è§†é¢‘ï¼Œéå¹¿å‘Š`);
+  }
+
+  return false;
+}
+
+function rewriteM3U8Content(lines: string[], baseUrl: string): string {
+  const rewrittenLines: string[] = [];
+  const variables = new Map<string, string>(); // ç”¨äº EXT-X-DEFINE å˜é‡æ›¿æ¢
+
+  for (let i = 0; i < lines.length; i++) {
+    let line = lines[i];
+    // å¤„ç†éæ ‡ç­¾è¡Œï¼ˆTSç‰‡æ®µã€åµŒå¥—M3U8ç­‰ï¼‰
+    if (!line.startsWith('#')) {
+      const resolvedUrl = resolveUrl(baseUrl, line);
+      rewrittenLines.push(resolvedUrl);
+      continue;
+    }
+    // ä½¿ç”¨ switch å¤„ç†å„ç§æ ‡ç­¾
+    switch (true) {
+      // å¤„ç†å˜é‡å®šä¹‰ (EXT-X-DEFINE)
+      case line.startsWith('#EXT-X-DEFINE:'):
+        line = processDefineVariables(line, variables);
+        break;
+      // å¤„ç† EXT-X-MAP æ ‡ç­¾ä¸­çš„ URI
+      case line.startsWith('#EXT-X-MAP:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // å¤„ç† EXT-X-KEY æ ‡ç­¾ä¸­çš„ URI
+      case line.startsWith('#EXT-X-KEY:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // å¤„ç† EXT-X-MEDIA æ ‡ç­¾ä¸­çš„ URI (éŸ³é¢‘è½¨é“ç­‰)ï¼Œæ— æ•ˆéŸ³è½¨ç•™ç»™ mpv
+      case line.startsWith('#EXT-X-MEDIA:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // å¤„ç† LL-HLS éƒ¨åˆ†ç‰‡æ®µ (EXT-X-PART)
+      case line.startsWith('#EXT-X-PART:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // å¤„ç†é¢„åŠ è½½æç¤º (EXT-X-PRELOAD-HINT)
+      case line.startsWith('#EXT-X-PRELOAD-HINT:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // å¤„ç†ä¼šè¯æ•°æ® (EXT-X-SESSION-DATA) - å¯èƒ½åŒ…å« URI
+      case line.startsWith('#EXT-X-SESSION-DATA:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // å¤„ç†ä¼šè¯å¯†é’¥ (EXT-X-SESSION-KEY)
+      case line.startsWith('#EXT-X-SESSION-KEY:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // å¤„ç†å†…å®¹å¯¼å‘ (EXT-X-CONTENT-STEERING)
+      case line.startsWith('#EXT-X-CONTENT-STEERING:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'SERVER-URI');
+        break;
+      // å¤„ç†æ¸²æŸ“æŠ¥å‘Š (EXT-X-RENDITION-REPORT)
+      case line.startsWith('#EXT-X-RENDITION-REPORT:'):
+        line = rewriteTagUri(line, baseUrl, variables, 'URI');
+        break;
+      // å¤„ç†æ—¥æœŸèŒƒå›´æ ‡ç­¾ä¸­çš„ URI (EXT-X-DATERANGE)
+      case line.startsWith('#EXT-X-DATERANGE:'):
+        line = rewriteDateRangeUris(line, baseUrl, variables);
+        break;
+
+      case line.startsWith('#EXT-X-STREAM-INF:'):
+        rewrittenLines.push(line);
+        // å¤„ç†ä¸‹ä¸€è¡Œçš„åµŒå¥—M3U8 URL
+        if (i + 1 < lines.length) {
+          i++;
+          const nextLine = lines[i].trim();
+          if (nextLine && !nextLine.startsWith('#')) {
+            let resolvedUrl = resolveUrl(baseUrl, nextLine);
+            resolvedUrl = substituteVariables(resolvedUrl, variables);
+            rewrittenLines.push(resolvedUrl);
+          } else {
+            rewrittenLines.push(nextLine);
+          }
+        }
+        continue;
+
+      // è¿™äº›æ ‡ç­¾ä¸éœ€è¦å¤„ç†ï¼Œç›´æ¥ä¿ç•™
+      // æœåŠ¡å™¨æ§åˆ¶ (EXT-X-SERVER-CONTROL)
+      //case line.startsWith('#EXT-X-SERVER-CONTROL:'):
+      // è·³è¿‡ç‰‡æ®µ (EXT-X-SKIP)
+      //case line.startsWith('#EXT-X-SKIP:'):
+      //  break;
+      // å…¶ä»–æœªçŸ¥æ ‡ç­¾ç›´æ¥ä¿ç•™
+      default:
+        break;
+    }
+    rewrittenLines.push(line);
+  }
+
+  return rewrittenLines.join('\n');
+}
+
+// å¤„ç†å˜é‡å®šä¹‰
+function processDefineVariables(line: string, variables: Map<string, string>): string {
+  const nameMatch = line.match(/NAME="([^"]+)"/);
+  const valueMatch = line.match(/VALUE="([^"]+)"/);
+  if (nameMatch && valueMatch) {
+    variables.set(nameMatch[1], valueMatch[1]);
+  }
+  return line; // è¿”å›åŸå§‹æ ‡ç­¾ï¼Œè®©å®¢æˆ·ç«¯å¤„ç†
+}
+
+// å˜é‡æ›¿æ¢å‡½æ•° - å‚è€ƒ hls.js æ ‡å‡†å®ç°
+const VARIABLE_REPLACEMENT_REGEX = /\{\$([a-zA-Z0-9-_]+)\}/g;
+
+function substituteVariables(text: string, variables: Map<string, string>): string {
+  if (variables.size === 0) {
+    return text;
+  }
+
+  return text.replace(VARIABLE_REPLACEMENT_REGEX, (variableReference: string, variableName: string) => {
+    const variableValue = variables.get(variableName);
+    if (variableValue === undefined) {
+      if (process.env.NODE_ENV === 'development') {
+        console.warn(`Missing variable definition for: "${variableName}"`);
+      }
+      return variableReference; // ä¿æŒåŸå§‹å¼•ç”¨å¦‚æœå˜é‡æœªå®šä¹‰
+    }
+    return variableValue;
+  });
+}
+
+// é€šç”¨çš„ URI é‡å†™å‡½æ•°ï¼Œæˆ–å…¶ä»– attrName
+function rewriteTagUri(line: string, baseUrl: string, variables: Map<string, string>, attrName: string): string {
+  const regex = new RegExp(`${attrName}="([^"]+)"`);
+  const match = line.match(regex);
+  if (match) {
+    let originalUri = match[1];
+    // å˜é‡æ›¿æ¢
+    if (variables) {
+      originalUri = substituteVariables(originalUri, variables);
+    }
+    const resolvedUrl = resolveUrl(baseUrl, originalUri);
+    return line.replace(match[0], `${attrName}="${resolvedUrl}"`);
+  }
+  return line;
+}
+
+// å¤„ç†æ—¥æœŸèŒƒå›´ä¸­çš„å¤šä¸ªURI
+function rewriteDateRangeUris(line: string, baseUrl: string, variables: Map<string, string>): string {
+  const uriMatches = Array.from(line.matchAll(/([A-Z-]+)="([^"]*(?:https?:\/\/|\/)[^"]*)"/g));
+  let result = line;
+  for (const match of uriMatches) {
+    const [fullMatch, , originalUri] = match;
+    if (originalUri.includes('://') || originalUri.startsWith('/')) {
+      let uri = originalUri;
+      if (variables) {
+        uri = substituteVariables(uri, variables);
+      }
+      const resolvedUrl = resolveUrl(baseUrl, uri);
+      result = result.replace(fullMatch, fullMatch.replace(originalUri, resolvedUrl));
+    }
+  }
+  return result;
+}
