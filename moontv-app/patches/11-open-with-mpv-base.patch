diff --git a/src/app/play/page.tsx b/src/app/play/page.tsx
index 99886e2..5c8bc77 100644
--- a/src/app/play/page.tsx
+++ b/src/app/play/page.tsx
@@ -42,6 +42,8 @@ interface WakeLockSentinel {
   removeEventListener(type: 'release', listener: () => void): void;
 }
 
+import MPVPlayButton from '@/components/MPVPlayButton';
+
 function PlayPageClient() {
   const router = useRouter();
   const searchParams = useSearchParams();
@@ -1838,6 +1840,15 @@ function PlayPageClient() {
                 {` > ${detail?.episodes_titles?.[currentEpisodeIndex] || `第 ${currentEpisodeIndex + 1} 集`}`}
               </span>
             )}
+            {/* 非移动设备，同一行使用 MPVPlayButton 组件 */}
+            <MPVPlayButton
+              videoUrl={videoUrl}
+              videoTitle={videoTitle}
+              videoDoubanId={videoDoubanId}
+              detail={detail}
+              currentEpisodeIndex={currentEpisodeIndex}
+              artPlayerRef={artPlayerRef}
+            />
           </h1>
         </div>
         {/* 第二行：播放器和选集 */}
diff --git a/src/components/MPVPlayButton.tsx b/src/components/MPVPlayButton.tsx
new file mode 100644
index 0000000..3cd131c
--- /dev/null
+++ b/src/components/MPVPlayButton.tsx
@@ -0,0 +1,348 @@
+/* eslint-disable no-console */
+
+'use client';
+
+import { useCallback,useEffect, useRef, useState } from 'react';
+
+import { SearchResult } from '@/lib/types';
+
+interface ArtPlayerInstance {
+  pause: () => void;
+  currentTime: number;
+  paused: boolean;
+  // 仅列出需要的属性和方法
+}
+
+interface MPVPlayButtonProps {
+  videoUrl: string;
+  videoTitle: string;
+  videoDoubanId: number;
+  detail: SearchResult | null;
+  currentEpisodeIndex: number;
+  artPlayerRef: React.MutableRefObject<ArtPlayerInstance | null>;
+}
+
+// 工具函数：安全 base64 编码
+const safeU8Base64 = (str: string): string => {
+  const b64 = btoa(unescape(encodeURIComponent(str)));
+  return b64.replace(/\//g, "_").replace(/\+/g, "-").replaceAll("=", "");
+};
+
+// 工具函数：检测是否为移动设备
+const isMobileDevice = (): boolean => {
+  if (typeof navigator === 'undefined') return false;
+  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
+};
+
+// 弹幕 URL 地址 API 响应类型
+interface DanmakuUrlsResponse {
+  total: number;
+  platforms: string[];
+  xmlurls: string[];
+}
+
+// 缓存接口
+interface CacheEntry {
+  data: DanmakuUrlsResponse | null;
+  timestamp: number;
+  loading: boolean;
+}
+
+// 弹幕 URL 地址 API 缓存（内存缓存）
+const danmakuUrlsCache = new Map<string, CacheEntry>();
+
+// 获取缓存键
+const getCacheKey = (doubanId: number, title: string, episode: number): string => {
+  return `${doubanId}-${title}-${episode}`;
+};
+
+export default function MPVPlayButton({
+  videoUrl,
+  videoTitle,
+  videoDoubanId,
+  detail,
+  currentEpisodeIndex,
+  artPlayerRef
+}: MPVPlayButtonProps) {
+  const [isMobile, setIsMobile] = useState(false);
+  const [filteredVideoUrl, setFilteredVideoUrl] = useState<string>(''); // 过滤后的视频地址
+  const [m3u8Filter, setM3u8Filter] = useState('on'); // on(default), off
+  const [danmakuUrlsStatus, setDanmakuUrlsStatus] = useState<'idle' | 'loading' | 'ready' | 'error'>('idle');
+
+  // 使用 ref 存储当前缓存键，避免重复请求
+  const currentCacheKeyRef = useRef<string>('');
+
+  // 检测设备类型
+  useEffect(() => {
+    setIsMobile(isMobileDevice());
+  }, []);
+
+  // 生成唯一的临时 key for filteredVideoUrl
+  const generateTempKey = useCallback((url: string): string => {
+    // 使用简单的哈希函数处理 url
+    let hash = 0;
+    for (let i = 0; i < url.length; i++) {
+      const char = url.charCodeAt(i);
+      hash = ((hash << 5) - hash) + char;
+      hash = hash | 0; // Convert to 32bit integer
+    }
+    // timestamp, 8小时毫秒数内不变
+    const ts8h = Math.floor(Date.now()/3600/8000);
+    // 简单哈希('mpv')=3*7*7*11*67=108339; 8339=31*269
+    const hashstr = (Math.abs(hash)*ts8h*8339).toString(36);
+    return hashstr.length >= 9 ? hashstr.substring(2, 9) : hashstr.substring(0, 7);
+  }, []);
+
+  // 在组件挂载时从 localStorage 读取 mpvM3u8Filter: 'true', 'false', null
+  useEffect(() => {
+    const savedMpvM3u8Filter = localStorage.getItem('mpvM3u8Filter');
+    if (savedMpvM3u8Filter && !JSON.parse(savedMpvM3u8Filter)) {
+      setM3u8Filter('off');
+    }
+  }, []); // 空依赖数组表示只在挂载时执行
+
+  // 过滤 M3U8 地址 - 使用临时认证的 key
+  const filterM3U8Url = useCallback(async (url: string): Promise<string> => {
+    // 如果不是 m3u8 地址，直接返回原地址
+    if (!url.endsWith('.m3u8')) {
+      console.warn('[MPV] 非 M3U8 地址，使用原始地址');
+      return url;
+    }
+
+    try {
+      console.log('[MPV] 开始注册过滤 M3U8 地址:', url);
+      // 生成临时 key
+      const urlKey = generateTempKey(url);
+
+      // 发送 POST 请求注册 key
+      const response = await fetch('/api/m3u8-register', {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+        },
+        body: JSON.stringify({
+          key: urlKey,
+          original_url: url
+        })
+      });
+
+      if (response.ok) {
+        const result = await response.json();
+        if (result.success) {
+          // 构建新的过滤地址
+          // 通过 middleware 匹配: api/register，mpv 跳过认证
+          const filteredUrl = `${window.location.origin}/api/registered.m3u8?key=${urlKey}&filter=${m3u8Filter}`;
+          console.log('[MPV] M3U8 过滤注册成功，使用过滤后地址:', filteredUrl);
+          return filteredUrl;
+        } else {
+          console.warn('[MPV] M3U8 过滤注册失败，使用原始地址');
+          return url;
+        }
+      } else {
+        console.warn('[MPV] M3U8 过滤注册请求失败，使用原始地址');
+        return url;
+      }
+    } catch (error) {
+      console.error('[MPV] M3U8 过滤注册错误:', error);
+      return url;
+    }
+  }, [generateTempKey, m3u8Filter]);
+
+  // 处理视频地址过滤
+  useEffect(() => {
+    const processVideoUrl = async () => {
+      if (!videoUrl) {
+        setFilteredVideoUrl('');
+        return;
+      }
+      console.log('[MPV] 原始视频地址：', videoUrl);
+      const filteredUrl = await filterM3U8Url(videoUrl);
+      setFilteredVideoUrl(filteredUrl);
+      console.log('[MPV] 最终视频地址：', filteredUrl);
+    };
+    processVideoUrl();
+  }, [videoUrl, filterM3U8Url]);
+
+  // 预先加载弹幕 URL 地址
+  useEffect(() => {
+    if (isMobile || (!videoDoubanId && !videoTitle)) return;
+
+    const cacheKey = getCacheKey(videoDoubanId, videoTitle, currentEpisodeIndex + 1);
+    currentCacheKeyRef.current = cacheKey;
+
+    // 检查缓存
+    const cachedEntry = danmakuUrlsCache.get(cacheKey);
+    if (cachedEntry) {
+      setDanmakuUrlsStatus(cachedEntry.data ? 'ready' : 'error');
+      return; // 使用有效缓存
+    }
+
+    // 标记为弹幕 URL 加载中
+    setDanmakuUrlsStatus('loading');
+    danmakuUrlsCache.set(cacheKey, { data: null, timestamp: Date.now(), loading: true });
+
+    const preloadDanmakuUrls = async () => {
+      try {
+        const params = new URLSearchParams();
+        if (videoDoubanId > 0) {
+          params.append('douban_id', videoDoubanId.toString());
+        }
+        if (videoTitle) {
+          params.append('title', videoTitle);
+        }
+        if (currentEpisodeIndex > 0) {
+          params.append('episode', (currentEpisodeIndex + 1).toString());
+        }
+        params.append('timeout', '10');
+
+        console.log('[MPV] 预加载弹幕 URL 请求参数:', params.toString());
+        const response = await fetch(`/api/danmaku-xmlurl?${params.toString()}`, {
+          headers: { 'Content-Type': 'application/json' },
+        });
+
+        if (response.ok) {
+          const urlsData = await response.json();
+          if (urlsData && urlsData.total > 0) {
+            // 更新缓存
+            danmakuUrlsCache.set(cacheKey, {
+              data: urlsData,
+              timestamp: Date.now(),
+              loading: false
+            });
+            setDanmakuUrlsStatus('ready');
+            console.log('[MPV] 弹幕 URL 地址预加载完成');
+          } else {
+            // 即使没有数据也缓存结果，避免重复请求
+            danmakuUrlsCache.set(cacheKey, {
+              data: null,
+              timestamp: Date.now(),
+              loading: false
+            });
+            setDanmakuUrlsStatus('error');
+            console.log('[MPV] 弹幕 URL 地址为空');
+          }
+        } else {
+          const errorText = await response.text();
+          console.error('[MPV] 弹幕 URL 地址预加载失败:', response.status, errorText);
+          danmakuUrlsCache.set(cacheKey, {
+            data: null,
+            timestamp: Date.now(),
+            loading: false
+          });
+          setDanmakuUrlsStatus('error');
+        }
+      } catch (error) {
+        console.error('[MPV] 弹幕 URL 地址预加载异常:', error);
+        danmakuUrlsCache.set(cacheKey, {
+          data: null,
+          timestamp: Date.now(),
+          loading: false
+        });
+        setDanmakuUrlsStatus('error');
+      }
+    };
+
+    preloadDanmakuUrls();
+  }, [videoDoubanId, videoTitle, currentEpisodeIndex, isMobile]);
+
+  // 工具函数：生成 MPV 播放地址（同步函数，使用预加载的弹幕 URL 地址）
+  const generateMPVUrl = (currentTime?: number): string => {
+    const finalVideoUrl = filteredVideoUrl || videoUrl;
+    console.log('[MPV] 视频地址：', finalVideoUrl);
+    const v_title = (detail?.episodes?.length || 0) > 1
+      ? `${videoTitle || '影片标题'} - ${detail?.episodes_titles?.[currentEpisodeIndex] || `第${currentEpisodeIndex + 1}集`}`
+      : `${videoTitle || '影片标题'}`;
+    console.log('[MPV] 视频标题：', v_title);
+    let mpvurl = `mpv://play/${safeU8Base64(finalVideoUrl)}/?v_title=${safeU8Base64(v_title)}`;
+
+    // 使用预加载的弹幕 URL 地址
+    const cacheKey = currentCacheKeyRef.current;
+    const cachedEntry = danmakuUrlsCache.get(cacheKey);
+    if (cachedEntry && cachedEntry.data && cachedEntry.data.total > 0) {
+      console.log('[MPV] 使用预加载的弹幕 URL 地址');
+      const urlsData = cachedEntry.data;
+      // platforms, xmlurls
+      for (let i = 0; i < urlsData.total; i++) {
+        const danmurl = urlsData.xmlurls[i];
+        const platform = urlsData.platforms[i];
+        console.log(`[MPV] 添加 ${platform} 弹幕地址：`, danmurl);
+        mpvurl += `&danmaku_xmlurl=${safeU8Base64(danmurl)}`;
+      }
+    } else {
+      console.log('[MPV] 无弹幕 URL 地址可用');
+    }
+
+    // 添加开始时间，若播放时间大于5秒
+    if (currentTime && currentTime > 5) {
+      mpvurl += `&startat=${Math.floor(currentTime) - 1}`;
+    }
+
+    console.log('[MPV] 播放地址：', mpvurl);
+    return mpvurl;
+  };
+
+  // 如果没有视频地址或是移动设备，不渲染按钮
+  if (!videoUrl || isMobile) {
+    return null;
+  }
+
+  const handleMPVPlay = () => {
+    const currentPlayTime = artPlayerRef.current?.currentTime || 0;
+    const finalMpvUrl = generateMPVUrl(currentPlayTime);
+
+    // 暂停播放器
+    if (artPlayerRef.current && !artPlayerRef.current.paused) {
+      artPlayerRef.current.pause();
+    }
+
+    // 打开 MPV 播放窗口
+    //  "_blank": 新窗口。artPlayer 仅暂停。
+    //  "_self": 页面卸载时, handleBeforeUnload, artPlayer 资源会被清理，比仅暂停更省资源。(NOT-TODO) 可添加状态判断，阻止清理。
+    //  "open-with-mpv": specified 新窗口，避免多个 blank 窗口。
+    const targetName = "open-with-mpv";
+    const targetTitle = `${document.title} | MPV`;
+    const mpvWindow = window.open(finalMpvUrl, targetName);
+
+    if (mpvWindow && mpvWindow.document) {
+      mpvWindow.document.title = targetTitle;
+    }
+  };
+
+  // 根据 filteredVideoUrl显示不同的按钮 title
+  const getButtonTitle = () => {
+    if (filteredVideoUrl !== videoUrl) {
+      //return `${videoUrl}&#013;&#010; -> ${filteredVideoUrl}`; // HOWTO &#?
+      return `${videoUrl}
+-> ${filteredVideoUrl}`;
+    } else {
+      return videoUrl;
+    }
+  };
+
+  // 根据弹幕 URL 地址预加载状态显示不同的按钮文本
+  const getButtonText = () => {
+    switch (danmakuUrlsStatus) {
+      case 'loading':
+        return <span>MPV 播放 (弹幕URL加载中...)</span>;
+      case 'ready':
+        return <span>MPV 播放 ✓</span>;
+      case 'error':
+        return <span>MPV 播放 (无弹幕)</span>;
+      default:
+        return <span>MPV 播放</span>;
+    }
+  };
+
+  return (
+    <button
+      onClick={handleMPVPlay}
+      disabled={danmakuUrlsStatus === 'loading'}
+      className="ml-4 flex-shrink-0 hover:opacity-90 transition-all duration-200 hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
+      title={getButtonTitle()}
+    >
+      <div className="flex items-center gap-1.5 bg-blue-200 hover:bg-blue-400 dark:bg-blue-600 dark:hover:bg-blue-800 text-gray-600 dark:text-gray-300 px-3 py-1.5 rounded-full text-sm font-semibold shadow-md">
+        {getButtonText()}
+      </div>
+    </button>
+  );
+}
